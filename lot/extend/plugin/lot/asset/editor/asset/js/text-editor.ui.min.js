var TE_ui = function(o, editor, create) {

    var w = window,
        d = document,
        r = this,
        H = d.documentElement,
        R = d.head,
        B = d.body,
        hooks = {},
        target = editor.target,
        target_events = 'blur copy cut focus input keydown paste',
        config = extend({
            tools: 'undo redo',
            classes: {
                "": 'text-editor',
                header: '%1-header',
                body: '%1-body',
                footer: '%1-footer',
                button: '%1-button',
                separator: '%1-separator',
                i: 'fa fa-%1',
                tool: '%1-tool',
                content: '%1-content',
                description: '%1-description',
                overlay: '%1-overlay',
                modal: '%1-modal',
                drop: '%1-drop',
                bubble: '%1-bubble'
            }
        }, o),
        _TRUE = true,
        _FALSE = false,
        _NULL = null,
        _FUNCTION = function() {},
        _KEYDOWN = 'keydown',
        _KEYUP = 'keyup',
        _MOUSEDOWN = 'mousedown',
        _MOUSEUP = 'mouseup',
        _MOUSEMOVE = 'mousemove',
        _CLICK = 'click',
        _FOCUS = 'focus',
        _BLUR = 'blur';

    // add `command` method to `TE`
    editor.command = function(node, wrap) {
        var $ = editor.$(),
            a = '<' + node + '>',
            b = '</' + node.split(' ')[0] + '>',
            A = editor.esc(a),
            B = editor.esc(b),
            m = pattern('^' + A + '(.*?)' + B + '$'),
            m_A = pattern(A + '$'),
            m_B = pattern('^' + B);
        return editor.toggle(
            // when ...
            wrap ? !m.test($.value) : (!m_A.test($.before) && !m_B.test($.after)),
            // do ...
            [
                // first toggle
                function(r) {
                    r[0]().unwrap(a, b, 1).wrap(a, b, wrap)[1]();
                },
                // second toggle (the reset state)
                function(r) {
                    r[0]().unwrap(a, b, wrap)[1]();
                }
            ]
        );
    };

    function is_node(x) {
        return x instanceof HTMLElement;
    }

    function is_set(x) {
        return typeof x !== "undefined";
    }

    function is_function(x) {
        return typeof x === "function";
    }

    function is_string(x) {
        return typeof x === "string";
    }

    function is_object(x) {
        return typeof x === "object";
    }

    function hook_set(ev, fn, id) {
        if (!is_set(ev)) return hooks;
        if (!is_set(fn)) return hooks[ev];
        if (!is_set(hooks[ev])) hooks[ev] = {};
        if (!is_set(id)) id = Object.keys(hooks[ev]).length;
        return hooks[ev][id] = fn, r;
    }

    function hook_reset(ev, id) {
        if (!is_set(ev)) return hooks = {}, r;
        if (!is_set(id)) return hooks[ev] = {}, r;
        return delete hooks[ev][id], r;
    }

    function hook_fire(ev, a, id) {
        if (!is_set(hooks[ev])) return r;
        if (!is_set(id)) {
            for (var i in hooks[ev]) {
                hooks[ev][i].apply(r, a);
            }
        } else {
            if (is_set(hooks[ev][id])) {
                hooks[ev][id].apply(r, a);
            }
        }
        return r;
    }

    function event_exit(e) {
        if (e) e.preventDefault();
        return _FALSE;
    }

    function event_set(id, node, fn) {
        node.addEventListener(id, fn, _FALSE);
        hook_set('on:' + id, fn, dom_id(node));
    }

    function event_reset(id, node, fn) {
        node.removeEventListener(id, fn, _FALSE);
        hook_reset('on:' + id, dom_id(node));
    }

    function event_fire(id, data, node) {
        hook_fire('on:' + id, data, dom_id(node));
    }

    function events_set(ids, node, fn) {
        ids = trim(ids).split(/\s+/);
        for (var i = 0, len = ids.length; i < len; ++i) {
            event_set(ids[i], node, fn);
        }
    }

    function events_reset(ids, node, fn) {
        ids = trim(ids).split(/\s+/);
        for (var i = 0, len = ids.length; i < len; ++i) {
            event_reset(ids[i], node, fn);
        }
    }

    function events_fire(ids, node, data) {
        ids = trim(ids).split(/\s+/);
        for (var i = 0, len = ids.length; i < len; ++i) {
            event_fire(ids[i], node, data);
        }
    }

    function timer_set(fn, i) {
        w.setTimeout(fn, i);
    }

    function timer_reset(timer_set_fn) {
        w.clearTimeout(timer_set_fn);
    }

    function trim(s) {
        return s.replace(/^\s*|\s*$/g, "");
    }

    function trim_left(s) {
        return s.replace(/^\s+/, "");
    }

    function trim_right(s) {
        return s.replace(/\s+$/, "");
    }

    function edge(a, b, c) {
        if (a < b) return b;
        if (a > c) return c;
        return a;
    }

    function extend(a, b) {
        b = b || {};
        for (var i in b) {
            if (is_object(a[i]) && !is_node(a[i])) {
                a[i] = extend(a[i], b[i]);
            } else {
                a[i] = b[i];
            }
        }
        return a;
    }

    function format(s, data) {
        return s.replace(/%(\d+)/g, function(a, b) {
            --b;
            return is_set(data[b]) ? data[b] : a;
        });
    }

    function slug(s) {
        return trim(s
            .toLowerCase()
            .replace(/[^ \/a-z\d-]/g, '-')
            .replace(/([ -])+/g, '$1')
            .replace(/^-|-$/g, "")
        );
    }

    function pattern(a, b) {
        return new RegExp(a, b);
    }

    function point(node, e) {
        var x = !!e.touches ? e.touches[0].pageX : e.pageX,
            y = !!e.touches ? e.touches[0].pageY : e.pageY,
            left = offset(node).l,
            top = offset(node).t;
        while (node = node.offsetParent) {
            left += offset(node).l;
            top += offset(node).t;
        }
        return {
            x: x - left,
            y: y - top
        };
    }

    function offset(node) {
        return {
            l: node.offsetLeft,
            t: node.offsetTop
        };
    }

    function size(node) {
        return {
            w: node.offsetWidth,
            h: node.offsetHeight
        };
    }

    function closest(a, b) {
        while ((a = a.parentElement) && a !== b);
        return a;
    }

    var c = config.classes,
        f = [c[""]],
        dom_id_counter = 0,
        _container = el_set(c[""]),
        _header = el_set(format(c.header, f)),
        _body = el_set(format(c.body, f)),
        _footer = el_set(format(c.footer, f)),
        _tool = el_set(format(c.tool, f)),
        _content = target,
        _description = el_set(format(c.description, f)),
        _overlay = el_set(format(c.overlay, f)),
        _modal = el_set(format(c.modal, f)),
        _drop = el_set(format(c.drop, f)),
        _bubble = el_set(format(c.bubble, f)),
        _description_left = el_set('left', 'span'),
        _description_right = el_set('right', 'span'),
        _button, _icon;

    function dom_id(node) {
        var id = node.id;
        if (!id) {
            id = f[0] + '-dom:' + dom_id_counter;
            ++dom_id_counter;
            node.id = id;
        }
        return id;
    }

    function el(em, node, attr) {
        em = is_string(em) ? d.createElement(em) : em;
        if (is_object(attr)) {
            for (var i in attr) {
                var v = attr[i];
                if (is_function(v)) {
                    em[i] = v;
                } else {
                    if (v === _NULL) {
                        em.removeAttribute(i);
                    } else {
                        em.setAttribute(i, is_object(v) ? v.join(' ') : "" + v);
                    }
                }
            }
        }
        if (is_node(node)) {
            em.appendChild(node);
        } else {
            if (is_object(node)) {
                for (var i in node) {
                    if (is_node(node[i])) {
                        em.appendChild(node[i]);
                    } else {
                        if (node[i] !== _FALSE) em.innerHTML = node[i];
                    }
                }
            } else {
                if (is_set(node) && node !== _FALSE) em.innerHTML = node;
            }
        }
        return em;
    }

    function el_style(em, prop) {
        em = el(em);
        for (var i in prop) {
            em.style[i.replace(/\-([a-z])/g, function(a, b) {
                return b.toUpperCase();
            })] = prop[i];
        }
        return em;
    }

    function class_exist(node, s) {
        return pattern('(^|\\s)' + s + '(\\s|$)').test(node.className);
    }

    function class_set(node, s) {
        if (!class_exist(node, s)) {
            node.className = trim(node.className + ' ' + s);
        }
    }

    function class_reset(node, s) {
        node.className = trim(node.className.replace(pattern('(^|\\s)' + s + '(\\s|$)'), '$1$2'));
    }

    function content_set(node, s) {
        node.innerHTML = s;
    }

    function content_reset(node) {
        content_set(node, "");
    }

    function dom_exist(node, dom) {
        if (arguments.length === 1) {
            return node.parentNode || _FALSE;
        }
        return node && dom.parentNode === node ? dom.parentNode : _FALSE;
    }

    function dom_before(node, dom) {
        var parent = dom_exist(node);
        if (!parent) return;
        parent.insertBefore(dom, node);
    }

    function dom_after(node, dom) {
        var parent = dom_exist(node);
        if (!parent) return;
        parent.insertBefore(dom, node.nextElementSibling);
    }

    function dom_set(node, dom) {
        node.appendChild(dom);
    }

    function dom_begin(node, dom) {
        var c = node.firstChild;
        if (c) {
            dom_before(c, dom);
        } else {
            dom_set(node, dom);
        }
    }

    function dom_end(node, dom) {
        dom_set(node, dom);
    }

    function dom_reset(node) {
        var parent = dom_exist(node);
        if (parent) {
            parent.removeChild(node);
        }
    }

    function dom_content_reset(node) {
        content_reset(el(node, _FALSE, {
            style: _NULL
        }));
        dom_reset(node);
    }

    function el_set(a, b, c) {
        return el(b || 'div', c, {
            'class': a
        });
    }

    function do_word_counter() {
        var v = (_content.value || "").replace(/<[^<>]+?>/g, "");
        content_set(_description_right, ((v.match(/(\w+)/g) || []).length) + ' Words');
    }

    function do_update_source(e) {
        do_word_counter(), hook_fire('change', [r]);
    }

    do_update_source(); // trigger ...

    var maps = {},
        bounce = _NULL;

    function do_update_source_debounce() {
        timer_reset(bounce);
        bounce = timer_set(do_update_source, 1000);
    }

    r.create = function() {
        var C = format(c.content, f);
        if (class_exist(_content, C)) {
            r.destroy(); // destroy if already created
        }
        class_set(_content, C);
        var tools = is_string(config.tools) ? trim(config.tools).split(/\s+/) : config.tools,
            button_class = format(c.button, f),
            separator_class = format(c.separator, f),
            button_id, tool, is_separator, i;
        var mark = el('mark');
        dom_after(_content, mark);
        dom_set(_container, _header);
        dom_set(_container, _body);
        dom_set(_container, _footer);
        dom_set(_header, _tool);
        dom_set(_body, _content);
        dom_set(_footer, _description);
        dom_set(_description, _description_left);
        dom_set(_description, _description_right);
        dom_before(mark, _container);
        dom_reset(mark);
        for (i in tools) {
            tool = tools[i];
            if (!r.tools[tool]) continue;
            icon = r.tools[tool].i || tool;
            if (icon !== '|') {
                icon = slug(icon);
            }
            is_separator = icon === '|';
            _button = el_set(is_separator ? separator_class : button_class, is_separator ? 'span' : 'a');
            if (!is_separator) {
                button_id = c[""] + '-button:' + tool;
                _button.href = '#' + tool;
                _button.id = button_id;
                content_set(_button, '<i class="' + format(c.i, [icon]) + ' ' + button_id + '"></i>');
                event_set(_CLICK, _button, function(e) {
                    var id = this.hash.replace('#', "");
                    if (r.tools[id] && r.tools[id].click) r.tools[id].click(e, editor);
                    return event_exit(e);
                });
            }
            dom_set(_tool, _button);
        }
        events_set(target_events, _content, do_update_source_debounce);
        content_set(_description_left, 'Compose');
        return hook_fire('create', [r]);
    };

    r.destroy = function() {
        var C = format(c.content, f);
        if (!class_exist(_content, C)) return r;
        class_reset(_content, C);
        events_reset(target_events, _content, do_update_source_debounce);
        dom_before(_container, target);
        dom_content_reset(_header);
        dom_content_reset(_body);
        dom_content_reset(_footer);
        dom_content_reset(_container);
        dom_content_reset(_tool);
        dom_content_reset(_description);
        dom_content_reset(_description_left);
        dom_content_reset(_description_right);
        return hook_fire('destroy', [r]);
    };

    r.exit = function(select, k) {
        var fn = {
            overlay: function() {
                dom_content_reset(_overlay);
            },
            modal: function() {
                dom_content_reset(_modal);
            },
            drop: function() {
                dom_content_reset(_drop);
            },
            bubble: function() {
                dom_content_reset(_bubble);
            }
        }, i;
        if (!k) {
            for (i in fn) fn[i]();
        } else {
            if (is_object(k)) {
                for (i in k) fn[k[i]] && fn[k[i]]();
            } else {
                fn[k] && fn[k]();
            }
        }
        if (select) {
            editor.select();
        }
    };

    r.overlay = function(s, x, fn) {
        dom_set(_body, el(_overlay, s));
        if (x) {
            function exit() {
                r.exit(1);
                event_reset(_CLICK, _overlay, exit);
            }
            event_set(_CLICK, _overlay, exit);
        }
        if (is_function(fn)) fn(_overlay);
    };

    r.modal = function(o, fn) {
        var F = [format(c.modal, f)],
            O = {}, i, j;
        if (is_set(o.body)) {
            o.body = el('div', o.body, {
                'class': F + '-content'
            });
        }
        for (i in o) {
            F[1] = i;
            O[i] = el_set(F[0] + '-' + format(i, F[0]), 0, o[i]);
        }
        event_set(_MOUSEDOWN, O.header, event_exit);
        O.x = el_set(F[0] + '-x'); // add `close` button
        O.resize = el_set(F[0] + '-resize'); // add `resize` button
        content_reset(_modal);
        dom_set(_body, el(_modal, O));
        r.overlay("", 1);
        var drag = 0,
            x = 0,
            y = 0,
            w = 0,
            h = 0,
            W = 0,
            H = 0,
            o;
        function size_modal() {
            o = size(_modal);
            w = o.w;
            h = o.h;
            o = size(_overlay);
            W = o.w;
            H = o.h;
        }
        size_modal();
        el_style(_modal, {
            top: ((H / 2) - (h / 2)) + 'px',
            left: ((W / 2) - (w / 2)) + 'px'
        });
        event_set(_CLICK, O.x, function() {
            event_fire(_CLICK, [], _overlay);
        });
        event_set(_MOUSEDOWN, _body, function(e) {
            drag = e.target;
            o = point(_modal, e);
            x = o.x;
            y = o.y;
            size_modal();
        });
        event_set(_MOUSEUP, B, function() {
            drag = 0;
        });
        event_set(_MOUSEMOVE, _body, function(e) {
            var header = O.header,
                resize = O.resize,
                left, top;
            if (drag === header || closest(drag, header) === header) {
                o = point(_body, e);
                left = o.x - x;
                top = o.y - y;
                el_style(_modal, {
                    left: edge(left, 0, W - w) + 'px',
                    top: edge(top, 0, H - h) + 'px'
                });
            }
            if (drag === resize || closest(drag, resize) === resize) {
                o = point(_modal, e);
                el_style(_modal, {
                    width: o.x + 'px',
                    height: o.y + 'px'
                });
            }
        });
        if (is_function(fn)) {
            O.overlay = _overlay;
            O.modal = _modal;
            fn(O);
        }
    };

    r.drop = function(s, fn) {
        dom_set(B, el(_drop, s));
        r.overlay("", 1);
        if (is_function(fn)) {
            fn(_drop);
        }
    };

    r.bubble = function(s, fn) {
        dom_set(B, el(_bubble, s));
        r.overlay("", 1);
        if (is_function(fn)) {
            fn(_bubble);
        }
    };

    // seet default toolbar(s)
    r.tools = {
        undo: {
            i: 'undo',
            title: 'Undo',
            click: editor.undo
        },
        redo: {
            i: 'repeat',
            title: 'Redo',
            click: editor.redo
        }
    };

    // set default hotkey(s)
    r.keys = {
        'control+y': 'redo',
        'control+z': 'undo'
    };

    // configuration data
    r.config = config;

    r.parent = editor;
    r.parent.ui = r;
    r.extend = extend;
    r.dom = {
        container: _container,
        header: _header,
        body: _body,
        footer: _footer,
        overlay: _overlay,
        modal: _modal,
        drop: _drop,
        bubble: _bubble
    };
    r.event = {
        set: events_set,
        reset: events_reset,
        fire: events_fire
    };
    r.hooks = hooks;
    r.hook = {
        set: hook_set,
        reset: hook_reset,
        fire: hook_fire
    };

    return create ? r.create() : r;

};

TE.prototype.ui = function(o, create) {
    return new TE_ui(o, this, create);
};